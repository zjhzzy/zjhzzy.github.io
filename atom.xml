<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nlub&#39;s blog</title>
  
  
  <link href="http://zjhzzy.github.io/atom.xml" rel="self"/>
  
  <link href="http://zjhzzy.github.io/"/>
  <updated>2023-10-01T05:36:28.395Z</updated>
  <id>http://zjhzzy.github.io/</id>
  
  <author>
    <name>JinHong Zeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pair和tuple的使用</title>
    <link href="http://zjhzzy.github.io/2023/10/01/pair-and-tuple/"/>
    <id>http://zjhzzy.github.io/2023/10/01/pair-and-tuple/</id>
    <published>2023-10-01T03:58:22.000Z</published>
    <updated>2023-10-01T05:36:28.395Z</updated>
    
    <content type="html"><![CDATA[<p>pair和tuple是用来存储不同类型的值的容器<br>主要目的是为了方便存储和处理不同类型的数据，它们更适合在特定的情况下用于数据的组织和传递</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>std::pair 是类模板，提供在一个单元中存储两个相异类型的对象</p><h3 id="pair的初始化"><a href="#pair的初始化" class="headerlink" title="pair的初始化"></a>pair的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">float</span>&gt; pair = std::<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line"><span class="keyword">auto</span> pair = std::<span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="number">2.1</span>);</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int</span>,<span class="type">float</span>&gt; <span class="title">pair</span><span class="params">(<span class="number">10</span>,<span class="number">2.1</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="std-get"><a href="#std-get" class="headerlink" title="std::get()"></a>std::get()</h3><p>访问 pair 中的元素</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::pair&lt;<span class="type">int</span>, <span class="type">float</span>&gt; pair = std::<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pair中的int:%d\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(pair));<span class="comment">// 使用std::get访问存储在pair中的int类型元素</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pair中的float:%.1f\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">float</span>&gt;(pair));<span class="comment">// 使用std::get访问存储在pair中的float类型元素</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pair中的第一个元素:%d\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(pair));<span class="comment">// 使用std::get访问pair中的第一个元素</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pair中的第二个元素:%.1f\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(pair));<span class="comment">// 使用std::get访问pair中的第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair中的int:10</span><br><span class="line">pair中的float:2.1</span><br><span class="line">pair中的第一个元素:10</span><br><span class="line">pair中的第二个元素:2.1</span><br></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>类模板 std::tuple 是固定大小的异类值汇集。它是 std::pair 的泛用形式</p><h3 id="tuple的初始化"><a href="#tuple的初始化" class="headerlink" title="tuple的初始化"></a>tuple的初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>&gt; tuple = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line"><span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>,<span class="number">2.1</span>);</span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>,<span class="type">float</span>&gt; <span class="title">tuple</span><span class="params">(<span class="number">10</span>,<span class="number">2.1</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="std-get-1"><a href="#std-get-1" class="headerlink" title="std::get()"></a>std::get()</h3><p>元组式访问指定的元素</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个std::tuple，包含一个整数、一个浮点数和一个字符，使用std::make_tuple初始化</span></span><br><span class="line">  <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="number">2.1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第一个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第二个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第三个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的int类型元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的double类型元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的char类型元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">char</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple中的第一个元素:10</span><br><span class="line">tuple中的第二个元素:2.1</span><br><span class="line">tuple中的第三个元素:A</span><br><span class="line">tuple中的int类型元素:10</span><br><span class="line">tuple中的double类型元素:2.1</span><br><span class="line">tuple中的char类型元素:A</span><br></pre></td></tr></table></figure><h3 id="tuple-cat"><a href="#tuple-cat" class="headerlink" title="tuple_cat"></a>tuple_cat</h3><p>通过连接任意数量的元组来创建一个tuple<br>通俗点讲就是将两个tuple组成一个</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> tuple1 = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line">  <span class="keyword">auto</span> tuple2 = std::<span class="built_in">make_tuple</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="comment">// 使用 std::tuple_cat 将两个元组合并为一个新的元组</span></span><br><span class="line">  <span class="keyword">auto</span> tuple = std::<span class="built_in">tuple_cat</span>(tuple1, tuple2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第一个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第二个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第三个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;tuple中的第四个元素:&quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(tuple) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple中的第一个元素:10</span><br><span class="line">tuple中的第二个元素:2.1</span><br><span class="line">tuple中的第三个元素:A</span><br><span class="line">tuple中的第四个元素:B</span><br></pre></td></tr></table></figure><h3 id="tie"><a href="#tie" class="headerlink" title="tie"></a>tie</h3><p>创建左值引用的 tuple ，或将 tuple 解包为独立对象</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="comment">// 使用std::tie解包tuple中的元素，将其分别赋值给i和d</span></span><br><span class="line">  std::<span class="built_in">tie</span>(i, d) = tuple;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;i的值:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;d的值:&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i的值:10</span><br><span class="line">d的值:2.1</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>自动解包元组中的元素，将它们传递给函数作为参数</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>, <span class="number">2.1</span>);</span><br><span class="line">  <span class="comment">// 使用 std::apply 调用lambda函数，将tuple中的元素作为参数传递给lambda</span></span><br><span class="line">  std::<span class="built_in">apply</span>(</span><br><span class="line">      [](<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a的值:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b的值:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a的值:10</span><br><span class="line">b的值:2.1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;pair和tuple是用来存储不同类型的值的容器&lt;br&gt;主要目的是为了方便存储和处理不同类型的数据，它们更适合在特定的情况下用于数据的组织和传递&lt;/p&gt;
&lt;h2 id=&quot;pair&quot;&gt;&lt;a href=&quot;#pair&quot; class=&quot;headerlink&quot; title=&quot;pair</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>variant、optional 和 any</title>
    <link href="http://zjhzzy.github.io/2023/09/30/variant%E3%80%81optional-and-any/"/>
    <id>http://zjhzzy.github.io/2023/09/30/variant%E3%80%81optional-and-any/</id>
    <published>2023-09-30T13:06:28.000Z</published>
    <updated>2023-10-01T04:03:51.055Z</updated>
    
    <content type="html"><![CDATA[<p>variant、optional和any 这三个模板类是用来取代C风格的一些不安全的代码</p><p>optional<T> —— 持有T或为空<br>variant&lt;T,U&gt; —— 持有T或U（类似于union）<br>any —— 持有任意类型（类似于void*)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; var1 = <span class="number">7</span>; </span><br><span class="line">std::variant&lt;<span class="type">int</span>,string&gt; var2 = <span class="number">7</span>; </span><br><span class="line">std::any var3 = <span class="number">7</span>; </span><br><span class="line"><span class="keyword">auto</span> x1 = *var1 ;               <span class="comment">// 对 optional 解引用 </span></span><br><span class="line"><span class="keyword">auto</span> x2 = std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(var2);       <span class="comment">// 像访问 tuple 一样访问 variant </span></span><br><span class="line"><span class="keyword">auto</span> x3 = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(var3);  <span class="comment">// 转换 any</span></span><br></pre></td></tr></table></figure><h2 id="variant"><a href="#variant" class="headerlink" title="variant"></a>variant</h2><p>std::variant 表示一个类型安全的联合体（变化体）std::variant 的一个实例在任意时刻要么保有它的一个可选类型之一的值，要么在错误情况下无值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C风格</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">variant</span>&#123;</span><br><span class="line">    <span class="type">int</span>,</span><br><span class="line">    <span class="type">char</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++风格</span></span><br><span class="line"><span class="keyword">typedef</span> std::variant&lt;<span class="type">int</span>,<span class="type">char</span>&gt; variant;</span><br></pre></td></tr></table></figure><h4 id="visit"><a href="#visit" class="headerlink" title="visit"></a>visit</h4><p>以一或多个 variant 所保有的各实参调用所提供的函数对象</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 std::variant 变量，可以存放 int 或 char 类型的值，并初始化为整数 1022。</span></span><br><span class="line">  std::variant&lt;<span class="type">int</span>, <span class="type">char</span>&gt; variant = <span class="number">1022</span>;</span><br><span class="line">  <span class="comment">// 使用 std::visit 访问 variant 中的值，根据存储的类型输出不同的消息。</span></span><br><span class="line">  std::<span class="built_in">visit</span>(</span><br><span class="line">      [](<span class="keyword">auto</span> &amp;&amp;arg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;variant中存放的是int类型&quot;</span>); <span class="comment">// 如果存放的是int类型，输出此消息。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;, <span class="type">char</span>&gt;) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;variant中存放的是char类型&quot;</span>); <span class="comment">// 如果存放的是char类型，输出此消息。</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      variant);</span><br><span class="line">  <span class="comment">// 将 variant 的值更改为字符 &#x27;A&#x27;。</span></span><br><span class="line">  variant = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="comment">// 再次使用 std::visit 访问 variant 中的值，根据存储的类型输出不同的消息。</span></span><br><span class="line">  std::<span class="built_in">visit</span>(</span><br><span class="line">      [](<span class="keyword">auto</span> &amp;&amp;arg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;variant中存放的是int类型&quot;</span>); <span class="comment">// 如果存放的是int类型，输出此消息。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;, <span class="type">char</span>&gt;) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;variant中存放的是char类型&quot;</span>); <span class="comment">// 如果存放的是char类型，输出此消息。</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      variant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是给出部分示例，因为有些我自己还没看明白，所以后面会更新的</p><h4 id="holds-alternative"><a href="#holds-alternative" class="headerlink" title="holds_alternative"></a>holds_alternative</h4><p>检查某个 variant 是否当前持有某个给定类型</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 std::variant 变量，可以存放 int 或 char 类型的值，并初始化为整数 1022。</span></span><br><span class="line">  std::variant&lt;<span class="type">int</span>, <span class="type">char</span>&gt; variant = <span class="number">1022</span>;</span><br><span class="line">  <span class="comment">// 检查 variant 中是否存放的是 int 类型的值。</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(variant)) &#123;</span><br><span class="line">    <span class="comment">// 如果存放的是 int 类型的值，使用 std::get&lt;int&gt; 获取它，并以整数格式输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(variant));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">char</span>&gt;(variant)) &#123;</span><br><span class="line">    <span class="comment">// 如果存放的是 char 类型的值，使用 std::get&lt;char&gt; 获取它，并以字符格式输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">char</span>&gt;(variant));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 variant 的值更改为字符 &#x27;A&#x27;。</span></span><br><span class="line">  variant = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="comment">// 检查 variant 中是否存放的是 int 类型的值。</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(variant)) &#123;</span><br><span class="line">    <span class="comment">// 如果存放的是 int 类型的值，使用 std::get&lt;int&gt; 获取它，并以整数格式输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(variant));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">char</span>&gt;(variant)) &#123;</span><br><span class="line">    <span class="comment">// 如果存放的是 char 类型的值，使用 std::get&lt;char&gt; 获取它，并以字符格式输出。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">char</span>&gt;(variant));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-get-std-variant"><a href="#std-get-std-variant" class="headerlink" title="std::get(std::variant)"></a>std::get(std::variant)</h4><p>以给定索引或类型（如果类型唯一）读取 variant 的值，错误时抛出异常</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 std::variant 变量，可以存放 int 或 char 类型的值，并初始化为整数 1022。</span></span><br><span class="line">  std::variant&lt;<span class="type">int</span>, <span class="type">char</span>&gt; variant = <span class="number">1022</span>;</span><br><span class="line">  <span class="comment">// 使用get函数获取值并输出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(variant));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>std::optional 管理一个可选的容纳值，既可以存在也可以不存在的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C风格</span></span><br><span class="line"><span class="type">int</span> optional = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// C++风格</span></span><br><span class="line">std::optional&lt;<span class="type">int</span>&gt; optional = std::<span class="literal">nullopt</span>;</span><br></pre></td></tr></table></figure><h4 id="has-value"><a href="#has-value" class="headerlink" title="has_value"></a>has_value</h4><p>检查对象是否含值</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::optional&lt;<span class="type">int</span>&gt; optional = std::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">if</span> (!optional.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果optional为空就输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;optional为空&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>std::any 描述用于任何可拷贝构造类型的单个值的类型安全容器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C风格</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> *any = &amp;value;</span><br><span class="line"><span class="comment">// C++风格</span></span><br><span class="line">std::any any = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="has-value-1"><a href="#has-value-1" class="headerlink" title="has_value"></a>has_value</h4><p>检查对象是否含有值</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::any any = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (any.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果any不为空就输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;any不为空\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>返回所含值的 typeid</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::any any = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (any.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="comment">// any中存放的是int则输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;any中存放的是int类型\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="any-cast"><a href="#any-cast" class="headerlink" title="any_cast"></a>any_cast</h4><p>对被容纳对象的类型安全访问</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::any any = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (any.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;</span><br><span class="line">    <span class="comment">// any中存放的是int则输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;any中存放的是%d\n&quot;</span>,std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(any));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前variant、optional和any的使用也就这么点，后续我还会补充一些我遗漏的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;variant、optional和any 这三个模板类是用来取代C风格的一些不安全的代码&lt;/p&gt;
&lt;p&gt;optional&lt;T&gt; —— 持有T或为空&lt;br&gt;variant&amp;lt;T,U&amp;gt; —— 持有T或U（类似于union）&lt;br&gt;any —— 持有任意类型（类似于vo</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux下使用Socket实现Tcp服务器的示例以及解释</title>
    <link href="http://zjhzzy.github.io/2023/08/17/TCP-Server-Implementation-with-Socket-Programming-in-Linux/"/>
    <id>http://zjhzzy.github.io/2023/08/17/TCP-Server-Implementation-with-Socket-Programming-in-Linux/</id>
    <published>2023-08-17T00:21:26.000Z</published>
    <updated>2023-10-01T00:22:52.973Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下使用Socket实现Tcp服务器<span id="more"></span>并不困难简略下来就的流程就一段</p><p>socket –&gt; bind –&gt; listen –&gt; accept –&gt; recv&#x2F;send(处理数据) –&gt; close</p><p>这就是Linux下实现服务器的流程，接下来我会给出代码并且逐步解析</p><p>这之中用到的函数都可以在这篇文章里看到解释</p><p><a href="https://zjhzzy.github.io/2023/08/15/Socket-Programming-Functions-and-Structures-on-Linux/">Linux下Socket编程中需要用到的函数以及结构体</a></p><p>因为只是示例程序就<strong>不进行错误判断</strong>了，编写项目时还是需要错误判断的</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>这段代码简单的实现了一个Tcp服务器，功能是接收对端发送来的消息并且输出，再将消息发送给对端</p><p>接下来简单的解释这些代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bind</span>(sockfd, (sockaddr *)&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">listen</span>(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  sockaddr_in clientAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">socklen_t</span> clientAddrLen = <span class="keyword">sizeof</span> clientAddr;</span><br><span class="line">  <span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> recvByte = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvByte &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">close</span>(clientfd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s Say: %s&quot;</span>, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), buffer);</span><br><span class="line"><span class="type">int</span> sendByte = <span class="built_in">send</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> (sendByte &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">close</span>(clientfd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一些需要的变量</p><p>向socket中传三个参数</p><p><strong>AF_INET</strong>：使用 IPV4 地址族</p><p><strong>SOCK_STREAM</strong>：流式套接字</p><p><strong>IPPRORO_TCP</strong>：采用TCP协议</p><p>设置addr的值</p><p>因为是服务器所以将地址设置为 INADDR_ANY(0.0.0.0)</p><p>端口通过htons函数转换后赋值给sin_port</p><p>设置地址族为 AF_INET(IPV4)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8000</span>);</span><br><span class="line">addr.sin_family = AF_INET;</span><br></pre></td></tr></table></figure><p>绑定地址并启用监听(被动触发模式)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span>(sockfd, (sockaddr *)&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line"><span class="built_in">listen</span>(sockfd, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>声明clientAddr去接收客户端的地址，accept返回套接字的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in clientAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">socklen_t</span> clientAddrLen = <span class="keyword">sizeof</span> clientAddr;</span><br><span class="line"><span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br></pre></td></tr></table></figure><p>声明buffer去接收客户端发送的数据，进行错误检查是否成功接收到数据，如果没有就关闭套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> recvByte = <span class="built_in">recv</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recvByte &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">close</span>(clientfd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出对端发送来的数据，并将其发送给对端，使用memset清空buffer，进行错误检查是否成功发送数据，如果没有就关闭套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s Say: %s&quot;</span>, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), buffer);</span><br><span class="line"><span class="type">int</span> sendByte = <span class="built_in">send</span>(clientfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> (sendByte &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">close</span>(clientfd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行没有出错会输出一下消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对端地址 Say: 对端发来的消息</span><br><span class="line">对端地址 Say: 对端发来的消息</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1936117399&amp;auto=0&amp;height=66" style="transition-property: color, background, box-shadow, border-color; transition-delay: 0s, 0s, 0s, 0s; transition-duration: 0.2s, 0.2s, 0.2s, 0.2s; transition-timing-function: ease, ease, ease, ease; color: rgb(190, 190, 198); font-family: 霞鹜新晰黑, 霞鹜新晰黑, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 450; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(32, 33, 36); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux下使用Socket实现Tcp服务器</summary>
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://zjhzzy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下socket编程常用的数据格式转换函数</title>
    <link href="http://zjhzzy.github.io/2023/08/16/Data-format-conversion-functions-in-Linux-socket-programming/"/>
    <id>http://zjhzzy.github.io/2023/08/16/Data-format-conversion-functions-in-Linux-socket-programming/</id>
    <published>2023-08-16T00:38:30.000Z</published>
    <updated>2023-10-01T00:21:25.727Z</updated>
    
    <content type="html"><![CDATA[<p>Linux下socket编程常常会进行数据格式转换<span id="more"></span>，所以我就列出来一些常用的函数的使用方法、其作用等等</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="啥是主机字节序？啥是网络字节序？"><a href="#啥是主机字节序？啥是网络字节序？" class="headerlink" title="啥是主机字节序？啥是网络字节序？"></a>啥是主机字节序？啥是网络字节序？</h3><p>主机字节序指的是在特定计算机体系结构中多字节数据类型（就是字节数不为1的数据类型）在内存在存储的顺序</p><p>字节序两种顺序，一种是大端，一种是小端</p><p>大端模式 是低位字节存放在高地址，高位字节存放在低地址</p><p>通俗点讲就是如果有一个数组采用大端存储那么数组的第一个元素在一段内存的尾部，而数组的尾部却在那一段内存的头部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers[4] | 0x12 | 0x16 | 0x20 | numbers[0]</span><br></pre></td></tr></table></figure><p>小端模式是低位字节存放在低地址，高位字节存放在高地址</p><p>与大端的相反，如果有一个数组采用小端存储那么数组的第一个元素在那一段内存的头部，数组的尾部在那段内存的尾部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers[0] | 0x12 | 0x16 | 0x20 | numbers[4]</span><br></pre></td></tr></table></figure><p>主机字节序可能是大端<em>可能</em>是小端，但是小端的比较多，具体还是<em>取决于计算机</em></p><p>网络字节序一般采用的都是大端</p><p>所以在传输数据是要进行字节序的转换</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>本文中所有的函数需要导入<code>&lt;arpa/inet.h&gt;</code>头文件才能使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="htons"><a href="#htons" class="headerlink" title="htons"></a>htons</h3><p>将使用主机字节序的 uint16_t（unsigned int） 类型数据转换成使用网络字节序 uint16_t（unsigned int）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h3 id="htonl"><a href="#htonl" class="headerlink" title="htonl"></a>htonl</h3><p>将使用主机字节序的 uint32_t（unsigned int） 类型数据转换成使用网络字节序 uint32_t（unsigned int）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint32_t</span> ip = <span class="built_in">inet_network</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">htonl</span>(ip);</span><br></pre></td></tr></table></figure><h3 id="ntohs"><a href="#ntohs" class="headerlink" title="ntohs"></a>ntohs</h3><p>将使用网络字节序的 uint16_t（unsigned short int） 类型数据转换成使用主机字节序 uint16_t（unsigned short int）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span> addr);</span><br><span class="line"><span class="type">uint16_t</span> port = <span class="built_in">ntons</span>(addr.sin_port);</span><br></pre></td></tr></table></figure><h3 id="ntonl"><a href="#ntonl" class="headerlink" title="ntonl"></a>ntonl</h3><p>将使用网络字节序的 uint32_t（unsigned int） 类型数据转换成使用主机字节序 uint32_t（unsigned int）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr"></a>inet_addr</h3><p>将十进制字符串格式的<strong>IPV4</strong>地址转换成网络字节序的二进制格式</p><p>转换成功则返回对应的网络字节序的二进制数据，如果转换出错返回 <code>INADDR_NONE</code>（通常为-1）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="inet-network"><a href="#inet-network" class="headerlink" title="inet_network"></a>inet_network</h3><p>将十进制字符串格式的<strong>IPV4</strong>地址转换成二进制格式</p><p>注：<strong>返回的还是主机字节序不是网络字节序</strong></p><p>转换成功则返回<strong>IPV4</strong>地址的二进制格式数据，转换失败则返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_network</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">htonl</span>(<span class="built_in">inet_network</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"><span class="comment">// 因为 inet_network 函数只会将地址转换成二进制</span></span><br><span class="line"><span class="comment">// 所以需要 htonl 函数将其转换成网络字节序</span></span><br></pre></td></tr></table></figure><h3 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa"></a>inet_ntoa</h3><p>将网络字节序的二进制数据转换成主机字节序的十进制字符串格式的<strong>IPV4</strong>地址</p><p>注：<strong>返回的指针是指向静态缓冲区的，后续的调用会覆盖该缓冲区</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">char</span> *buffer = <span class="built_in">inet_ntoa</span>(addr.sin_addr); <span class="comment">// buffer = &quot;127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton"></a>inet_pton</h3><p>将主机字节序的十进制字符串格式的<strong>IP</strong>转换成网络字节序的二进制格式写入到dst中</p><p>如果成功转换并写入则返回 -1，如果src中的值为空则返回 0，如果af不是正确的地址族则返回 -1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure><p>af：使用的地址族</p><p>src：IP地址的字符串</p><p>dst：指向你要写入的那个缓冲区的指针</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in6 addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET6,<span class="string">&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</span>,&amp;addr.sin6_addr);</span><br><span class="line"><span class="comment">// 将第二个参数转换成网络字节序的二进制格式写入到 addr.sin6_addr 中</span></span><br></pre></td></tr></table></figure><h3 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop"></a>inet_ntop</h3><p>将网络字节序的二进制格式的<strong>IP</strong>地址 转换成主机字节序的十进制字符串格式写入到dst中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>af：使用的地址族</p><p>src：指向需要转换的IP地址的指针</p><p>dst：等待写入地址的字符串</p><p>size：地址的长度（用字节数表示）</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">char</span> data[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;addr: &quot;</span> &lt;&lt; <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr.sin_addr, data, <span class="number">16</span>);</span><br><span class="line"><span class="comment">// 输出 127.0.0.1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux下socket编程常常会进行数据格式转换</summary>
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://zjhzzy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下Socket编程中需要用到的函数以及结构体</title>
    <link href="http://zjhzzy.github.io/2023/08/15/Socket-Programming-Functions-and-Structures-on-Linux/"/>
    <id>http://zjhzzy.github.io/2023/08/15/Socket-Programming-Functions-and-Structures-on-Linux/</id>
    <published>2023-08-15T05:07:57.000Z</published>
    <updated>2023-10-05T16:13:06.278Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲究的就是一个实用，所以不会所有的东西都介绍，只会介绍常用的</p><p><strong>注：阅读本文前最好还是有些网络编程的基础概念比如大端小端之类的</strong></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a>sockaddr_in</h3><p>sockaddr_in是一个用来存放地址和端口的结构体，一般是IPV4协议使用</p><p>sin_family：存放使用的协议，必须是AF_INET（IPV4协议）</p><p>sin_port：存放的是端口</p><p>sin_addr：存放的是地址</p><p>sin_zero：我找到的解释是为了让sockaddr和sockaddr_in的大小一致，方便互相转换来占空间用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">short</span>            sin_family;   <span class="comment">/* AF_INET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>   sin_port;     </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>   sin_addr;     </span><br><span class="line">    <span class="type">char</span>             sin_zero[<span class="number">8</span>];  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_addr; <span class="comment">/* 地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sockaddr-in6"><a href="#sockaddr-in6" class="headerlink" title="sockaddr_in6"></a>sockaddr_in6</h3><p>sockaddr_in6和sockaddr_in都是用来存放地址和端口的结构体，不同的地方就是sockaddr_in6是提供给IPV6协议使用的</p><p>sin6_family：存放使用的协议，必须是AF_INET6（IPV6协议）</p><p>sin6_port：存放的是端口</p><p>sin6_flowinfo：流信息，一般情况下不需要显式的设置或使用sin6_flowinfo</p><p>sin6_addr：存放的是地址，是一个结构体</p><p>sin6_scope_id：地址范围的标识符，只有需要指定特定地址范围标识符时才会去显式设置其值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line"><span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line"><span class="type">in_port_t</span>       sin6_port;     </span><br><span class="line"><span class="type">uint32_t</span>        sin6_flowinfo; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;     </span><br><span class="line"><span class="type">uint32_t</span>        sin6_scope_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];  <span class="comment">/* 地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="msghdr"><a href="#msghdr" class="headerlink" title="msghdr"></a>msghdr</h3><p>msg_name：存放地址结构体（sockaddr、sockaddr_in、sockaddr_in6）</p><p>msg_namelen：地址结构体的长度（以字节数表示）</p><p>msg_iov：指向iovec结构体的指针，里面存放着消息</p><p>msg_iovlen：msg_iov这个数组的长度</p><p>msg_control：辅助数据，一般传递其他与消息相关的信息，比如带外数据（Out-of-band-data）</p><p>msg_controllen：辅助数据的长度（以字节数表示）</p><p>iov_base：存放着数据</p><p>iov_len：存放着iov_base指向的数据的长度（以字节数表示）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> &#123;</span><br><span class="line"><span class="type">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line"><span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line"><span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line"><span class="type">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line"><span class="type">size_t</span>  msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line"><span class="type">int</span>           msg_flags;      <span class="comment">/* Flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line"><span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>这个函数是用来创建套接字的，创建成功会返回一个文件描述符，如果创建失败便会返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure><p><strong>domain</strong></p><p>地址族</p><blockquote><p><code>AF_INET</code>：IPV4地址族，用于支持IPV4协议<br><code>AF_INET6</code>：IPV6地址族，用于支持IPV6协议<br><code>AF_UNIX</code> and AF_LOCAL：Unix域套接字地址族，用于同一台主机上通信</p></blockquote><p><strong>type</strong></p><p>套接字的类型</p><blockquote><p><code>SOCK_STREAM</code>：面向连接的可靠流式套接字<br><code>SOCK_DGRAM</code>：面向消息的报式套接字<br><code>SOCK_SEQPACKET</code>：面向连接的有序数据套接字<br><code>SOCK_RAW</code>：网络层原始套接字</p></blockquote><p><strong>protocol</strong></p><p>传输协议</p><ol><li><p><code>SOCK_STREAM</code></p><blockquote><p><code>IPPROTO_TCP</code>：TCP协议，一种面向连接的、可靠的、基于字节流的传输协议</p></blockquote></li><li><p><code>SOCK_DGRAM</code></p><blockquote><p><code>IPPROTO_UDP</code>：UDP协议，一种无连接的、不可靠的，基于报文的传输协议</p></blockquote></li><li><p><code>SOCK_RAW</code></p><blockquote><p><code>IPPROTO_RAW</code>：原始套接字协议，允许应用程序直接访问底层网络协议栈，可以用于构造自定义的网络协议<br><code>IPPROTO_ICMP</code>：互联网控制消息协议（ICMP），用于网络设备之间传递错误和控制消息<br><code>IPPROTO_IP</code>：IP协议，是基于IP地址的网络层协议，用于在网络中传输数据包</p></blockquote></li><li><p><code>SOCK_SEQPACKET</code></p><blockquote><p><code>IPPROTO_SCTP</code>：流控制传输协议（SCTP）提供类似TCP的可靠性和有序性</p></blockquote></li></ol><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>给套接字绑定地址，如果成功返回0，发生错误就返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>addr</strong></p><p>指向sockaddr结构体的指针</p><p><strong>addrlen</strong></p><p>地址结构体的字节数</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr = INADDR_ANY; <span class="comment">// 这里的INADDR_ANY代表 0.0.0.0 可以理解成本地的意思</span></span><br><span class="line">addr.sin_port = <span class="built_in">honts</span>(<span class="number">8080</span>); <span class="comment">// 使用honts函数从主机字节序转换到网络字节序，下一篇文章会讲</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">bind</span>(sockfd,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span> addr);  <span class="comment">// 这里使用了C风格的强转将sockaddr_in指针转换成sockaddr</span></span><br></pre></td></tr></table></figure><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>将套接字设置成监听（被动）模式</p><p>如果成功返回0，发生错误就返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>backlog</strong></p><p>请求队列的最大数量</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd,<span class="number">128</span>);</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p><strong>流式套接字</strong>发送连接请求，连接到服务器就返回0，如果发生错误就返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>addr</strong></p><p>指向sockaddr结构体的指针</p><p><strong>addrlen</strong></p><p>地址结构体的长度（以字节数表示）</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;117.21.32.217&quot;</span>); <span class="comment">// 该ip为随机生成</span></span><br><span class="line">addr.sin_port = <span class="built_in">honts</span>(<span class="number">8080</span>);</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">connect</span>(sockfd,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span> addr);</span><br></pre></td></tr></table></figure><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p><strong>面向连接的套接字</strong>用来同意客户端发送的连接请求</p><p>会阻塞到有客户端发送连接请求</p><p>如果成功便会返回一个与客户端通信的套接字文件描述符，如果失败返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字文件描述符</p><p><strong>addr</strong></p><p>指向sockaddr结构体的指针，客户端的地址和端口会存储在里面</p><p><strong>addrlen</strong></p><p>指向地址结构体字节数的指针</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in clientAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">socklen_t</span> clientAddrLen = <span class="keyword">sizeof</span> clientAddr;</span><br><span class="line"><span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd,(sockaddr*)&amp;clientAddr,&amp;clientAddrLen);</span><br></pre></td></tr></table></figure><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>给<strong>面向连接的套接字</strong>发送数据的函数</p><p>如果不额外设置会阻塞到消息完全发出为止</p><p>发送<strong>成功</strong>返回发送数据的大小（以字节数表示），发生<strong>错误</strong>返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span></span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>buf</strong></p><p>指向要发送的数据的缓冲区的指针</p><p><strong>len</strong></p><p>要发送的数据的长度（以字节数表示）</p><p><strong>flags</strong></p><p>发送数据时标记</p><blockquote><p><code>MSG_DONTROUTE</code>：不查找路由表，直接发送数据<br><code>MSG_OOB</code>：发送带外数据（Out-of-band data）<br><code>MSG_NOSIGNAL</code>：忽略 <code>SIGPIPE</code> 信号，如果发送的数据超出接收端的缓冲区大小，不会导致程序终止<br><code>MSG_MORE</code>：表示还有更多数据待发送，用于 TCP 的流控制优化</p></blockquote><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span>(clientfd,<span class="string">&quot;Hei Client&quot;</span>,<span class="built_in">sizeof</span>(<span class="string">&quot;Hei Client&quot;</span>),MSG_MORE|MSG_OOB);</span><br><span class="line"><span class="comment">// 使用（|）运算符设置两个标记</span></span><br></pre></td></tr></table></figure><h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><p>一般给<strong>不连接的套接字</strong>用来发送报文</p><p>默认为阻塞模式</p><p>发送<strong>成功</strong>返回发送数据的大小（以字节数表示），发生<strong>错误</strong>返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>buf</strong></p><p>指向要发送的数据的缓冲区指针</p><p><strong>len</strong></p><p>要发送的数据的长度（以字节数表示）</p><p><strong>flags</strong></p><p>发送数据时的标记</p><blockquote><p><code>MSG_DONTROUTE</code>：不查找路由表，直接发送数据<br><code>MSG_OOB</code>：发送带外数据（Out-of-band data）<br><code>MSG_NOSIGNAL</code>：忽略 <code>SIGPIPE</code> 信号，如果发送的数据超出接收端的缓冲区大小，不会导致程序终止<br><code>MSG_DONTWAIT</code>：非阻塞模式发送，函数调用将立即返回，而不管是否能够发送全部数据，如果不能立即发送，则可能会发送部分数据</p></blockquote><p><strong>dest_addr</strong></p><p>指向sockaddr结构体的指针，结构体内存放的是数据的目标地址与端口</p><p><strong>addrlen</strong></p><p>地址结构体的长度（以字节数表示）</p><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8989</span>);</span><br><span class="line">addr.sin_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;143.131.180.94&quot;</span>);</span><br><span class="line"><span class="built_in">sendto</span>(sockfd,<span class="string">&quot;Hei Udp Client&quot;</span>,<span class="built_in">sizeof</span>(<span class="string">&quot;Hei Udp Client&quot;</span>),<span class="number">0</span>,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span> addr);</span><br><span class="line"><span class="comment">// 0 代表不使用任何标志参数</span></span><br></pre></td></tr></table></figure><h3 id="sendmsg"><a href="#sendmsg" class="headerlink" title="sendmsg"></a>sendmsg</h3><p>用于<strong>套接字</strong>发送数据</p><p>默认为阻塞模式</p><p>发送<strong>成功</strong>返回发送数据的大小（以字节数表示），发生<strong>错误</strong>返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>msg</strong></p><p>指向要发送的msghdr结构体的指针</p><p><strong>flags</strong></p><p>发送数据时的标记</p><blockquote><p><code>MSG_DONTWAIT</code>：以非阻塞方式发送消息，即使发送缓冲区已满也立即返回<br><code>MSG_EOR</code>：表示消息中的最后一个缓冲区的结束<br><code>MSG_MORE</code>：表示消息中还有更多的数据要发送<br><code>MSG_NOSIGNAL</code>：禁止在发送失败时产生 <code>SIGPIPE</code> 信号，而是返回错误码，以避免由于对端关闭连接而引发的异常信号</p></blockquote><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msghdr msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">iovec iov[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> message1[<span class="number">12</span>] = <span class="string">&quot;Hei Client!&quot;</span>;</span><br><span class="line"><span class="type">char</span> message2[<span class="number">23</span>] = <span class="string">&quot;Hi Message from server&quot;</span>;</span><br><span class="line">iov[<span class="number">0</span>].iov_base = message1;</span><br><span class="line">iov[<span class="number">1</span>].iov_base = message2;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span> message1;</span><br><span class="line">iov[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> message2;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">sendmsg</span>(sockfd, &amp;msg, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><p>用于套接字接收数据</p><p>如果不额外设置会阻塞到接收到数据</p><p>成功则返回接收到的数据的字节数（以字节数表示），失败则返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>buf</strong></p><p>指向用来接收数据的缓冲区指针</p><p><strong>len</strong></p><p>缓冲区的大小或可接收的最大字节数</p><p><strong>flags</strong></p><p>指定接收时的额外选项</p><blockquote><p><code>MSG_DONTWAIT</code>：非阻塞模式 即使没有可用的数据，也立即返回结果，不会阻塞等待数据到达<br><code>MSG_PEEK</code>：表示从接收队列中查看而不移除数据，可以用来检查接收缓冲区中的数据而不实际读取它们<br><code>MSG_WAITALL</code>：接收过程中一直等待请求的数据直到满足条件，如果没有足够的数据，则阻塞等待<br><code>MSG_OOB</code>：表示接收或发送带外数据（Out-of-Band） 这种数据具有高优先级，通常在正常数据之外进行处理</p></blockquote><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">recv</span>(sockfd,buffer,<span class="number">1024</span>,<span class="number">0</span>); <span class="comment">// 0 的意思没有指定额外的选项</span></span><br></pre></td></tr></table></figure><h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><p><strong>报式套接字</strong>用来接收数据的函数</p><p>默认为阻塞模式</p><p>成功则返回接收到的数据的字节数（以字节数表示），失败则返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>buf</strong></p><p>指向接收数据的缓冲区的指针</p><p><strong>len</strong></p><p>缓冲区的长度或可接收的最大字节数</p><p><strong>flags</strong></p><p>指定接收时的额外选项</p><blockquote><p><code>MSG_TRUNC</code>：如果接收缓冲区的大小小于接收到的数据报的大小，则截断数据<br><code>MSG_ERRQUEUE</code>：从错误队列接收错误消息<br><code>MSG_CMSG_CLOEXEC</code>：设置接收的辅助数据（控制消息）以 <code>FD_CLOEXEC</code> 标志关闭<br><code>MSG_DONTWAIT</code>：非阻塞模式 即使没有可用的数据，也立即返回结果，不会阻塞等待数据到达<br><code>MSG_PEEK</code>：表示从接收队列中查看而不移除数据，可以用来检查接收缓冲区中的数据而不实际读取它们<br><code>MSG_WAITALL</code>：接收过程中一直等待请求的数据直到满足条件，如果没有足够的数据，则阻塞等待</p></blockquote><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">socklen_t</span> addrLen = <span class="keyword">sizeof</span> addr;</span><br><span class="line"><span class="built_in">recvfrom</span>(sockfd,addr,<span class="number">1024</span>,MSG_WAITALL|MSG_PEEK,(sockaddr*)&amp;addr,&amp;addrLen);</span><br></pre></td></tr></table></figure><h3 id="recvmsg"><a href="#recvmsg" class="headerlink" title="recvmsg"></a>recvmsg</h3><p>用于套接字接收数据</p><p>默认为阻塞模式</p><p>成功返回接收到的数据的长度（以字节数表示），不成功返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>sockfd</strong></p><p>套接字的文件描述符</p><p><strong>msg</strong></p><p>指向用来接收数据的msghdr结构体的指针</p><p><strong>flags</strong></p><p>指定接收时的额外选项</p><blockquote><p><code>MSG_CMSG_CLOEXEC</code>：在接收到控制消息（cmsg）时自动将其标记为 <code>FD_CLOEXEC</code>，使得接收的文件描述符在执行 <code>exec</code> 系列函数时会被关闭<br><code>MSG_DONTWAIT</code>：设置非阻塞模式，即使没有可用的数据，也立即返回<br><code>MSG_ERRQUEUE</code>：接收错误消息队列中的消息 这个标志通常用于接收一些与套接字操作相关的错误信息，例如 ICMP 错误消息<br><code>MSG_OOB</code>：表示接收或发送带外数据（Out-of-Band） 这种数据具有高优先级，通常在正常数据之外进行处理<br><code>MSG_PEEK</code>：表示从接收队列中查看而不移除数据，可以用来检查接收缓冲区中的数据而不实际读取它们<br><code>MSG_TRUNC</code>：如果接收缓冲区大小小于接收到的消息的大小，则将该标志设置为指示消息被截断<br><code>MSG_WAITALL</code>：接收过程中一直等待请求的数据直到满足条件，如果没有足够的数据，则阻塞等待<br><code>MSG_DONTWAIT</code>：非阻塞模式 即使没有可用的数据，也立即返回结果，不会阻塞等待数据到达</p></blockquote><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msghdr msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">recvmsg</span>(sockfd, &amp;msg, MSG_OOB);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)msg.msg_control);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; msg.msg_iovlen; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)msg.msg_iov[i].iov_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文讲究的就是一个实用，所以不会所有的东西都介绍，只会介绍常用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：阅读本文前最好还是有些网络编程的基础概念比如大端小端之类的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://zjhzzy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Qt框架中的Json模块使用</title>
    <link href="http://zjhzzy.github.io/2023/08/14/Using-JSON-in-the-Qt-Framework/"/>
    <id>http://zjhzzy.github.io/2023/08/14/Using-JSON-in-the-Qt-Framework/</id>
    <published>2023-08-14T05:26:29.000Z</published>
    <updated>2023-09-30T12:08:30.100Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要介绍Qt框架下的Json模块的使用</p><p>注：Json模块已经嵌入到QCore中，无需引入其他模块</p><h2 id="需要使用的对象"><a href="#需要使用的对象" class="headerlink" title="需要使用的对象"></a>需要使用的对象</h2><h3 id="QJsonDocument"><a href="#QJsonDocument" class="headerlink" title="QJsonDocument"></a>QJsonDocument</h3><p>这是Qt提供的一个用来序列化以及反序列化Json文本的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QJsonDocument</span>(<span class="type">const</span> QJsonObject &amp;*object*)</span><br></pre></td></tr></table></figure><p>QJsonDocument常用的构造函数，会将传入的QJsonObject设置成主对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fromJson</span>(<span class="type">const</span> QByteArray &amp;json, QJsonParseError error = <span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><p>fromJson函数解析UTF-8编码的Json文本，并创建一个QJsonDocument对方返回，如果解析失败将会返回空值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span>()</span><br></pre></td></tr></table></figure><p>返回一个QJsonObject，如果文档为数组则返回空值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setObject</span>(<span class="type">const</span> QJsonObject &amp;object)</span><br></pre></td></tr></table></figure><p>将传入的QJsonObject设置成主对象，也就是Json文本的根对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">toJson</span>(QJsonDocument::JsonFormat *format* = Indented) <span class="type">const</span></span><br></pre></td></tr></table></figure><p>将存储在对象中的数据序列化为Json文本，需要传入一个变量，来确定转换之后的风格</p><blockquote><p>QJsonDocument::Indented 可读模式，这个是有缩进的风格也就是下文会给出的Json文本的风格</p><p>QJsonDocument::Compact 紧凑模式，这个风格没有缩进是紧凑风格，一般用来减少占用使用</p></blockquote><h3 id="QJsonObject"><a href="#QJsonObject" class="headerlink" title="QJsonObject"></a>QJsonObject</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>[](QString &amp;key)</span><br></pre></td></tr></table></figure><p>对应键值存在就返回对应的QJsonValueRef，如果不存在就创建新的键，将新的值与其关联起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">take</span>(<span class="type">const</span> QString &amp;key)</span><br></pre></td></tr></table></figure><p>对应键值存在就返回对应的QJsonValue并且在QJsonObject中删除该键，不存在就返回一个null</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">value</span>(<span class="type">const</span> QString &amp;key) <span class="type">const</span></span><br></pre></td></tr></table></figure><p>对应键值存在便返回对应的QJsonValue，不存在就返回一个默认值，不会引发错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(<span class="type">const</span> QString &amp;key, <span class="type">const</span> QJsonValue &amp;value)</span><br></pre></td></tr></table></figure><p>传入的第一个变量为键，第二个变量是其对应的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">erase</span>(QJsonObject::iterator it)</span><br></pre></td></tr></table></figure><p>擦除传入的迭代器指向的键值，并返回下一个对应的键值</p><h3 id="QJsonValue"><a href="#QJsonValue" class="headerlink" title="QJsonValue"></a>QJsonValue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isInt</span>()</span><br></pre></td></tr></table></figure><p>如果值包含int类型则返回true，其他的函数同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">toInt</span>(<span class="type">int</span> defaultValue = <span class="number">0</span>) <span class="type">const</span></span><br></pre></td></tr></table></figure><p>如果值为int or double类型便返回，如果值不是便返回defaultValue</p><p>其他to函数如果类型对应不上便返回defaultValue</p><p>toObject、toString、toArray如果不传入defaultValue便返回其无参构造函数构造的值</p><h3 id="QJsonArray"><a href="#QJsonArray" class="headerlink" title="QJsonArray"></a>QJsonArray</h3><p>这个比较好理解你只需要将其想成一个存放着QJsonValue的数组就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(qsizetype *i*) <span class="type">const</span></span><br></pre></td></tr></table></figure><p>返回对应索引位置的元素，i的值必须是有效索引位置(0&lt;&#x3D;i&lt;size)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">takeAt</span>(qsizetype i)</span><br></pre></td></tr></table></figure><p>删除对应索引位置的元素并将其返回，i的值必须是有效索引位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">removeAt</span>(qsizetype i)</span><br></pre></td></tr></table></figure><p>同上但是不返回任何值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>(<span class="type">const</span> QJsonValue &amp;value)</span><br></pre></td></tr></table></figure><p>将值插入到数组的末尾</p><h2 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h2><h3 id="反序列化示例"><a href="#反序列化示例" class="headerlink" title="反序列化示例"></a>反序列化示例</h3><p>我将给出一段代码，目的是反序列化这段Json文本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Text&quot;</span><span class="punctuation">:</span><span class="string">&quot;Hello Qt Json module&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Array&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ObjectName&quot;</span><span class="punctuation">:</span><span class="string">&quot;QWidget&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Widget&quot;</span><span class="punctuation">:</span><span class="number">1920</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;High&quot;</span><span class="punctuation">:</span><span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Hide&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ObjectName&quot;</span><span class="punctuation">:</span><span class="string">&quot;QLable&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Widget&quot;</span><span class="punctuation">:</span> <span class="number">114</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;High&quot;</span><span class="punctuation">:</span><span class="number">514</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Hide&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码反序列化了上面的Json文本并将存在里面的值输出了出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODeviceBase::ReadOnly);</span><br><span class="line">QJsonDocument document = QJsonDocument::<span class="built_in">fromJson</span>(file.<span class="built_in">readAll</span>());</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; document.<span class="built_in">object</span>()[<span class="string">&quot;Text&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line">QJsonArray array = document.<span class="built_in">object</span>()[<span class="string">&quot;Array&quot;</span>].<span class="built_in">toArray</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : array) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;ObjectName&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;Widget&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;High&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;Hide&quot;</span>].<span class="built_in">toBool</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来逐步解析一下</p><p>初始化file，设置文件名字为test.json</p><p>使用只读模式打开test.json文件</p><p>将test.json中的文本反序列化成QJsonDocument</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODeviceBase::ReadOnly);</span><br><span class="line">QJsonDocument document = QJsonDocument::<span class="built_in">fromJson</span>(file.<span class="built_in">readAll</span>());</span><br></pre></td></tr></table></figure><p>读取Text键的值，将其转换成QString类型并输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; document.<span class="built_in">object</span>()[<span class="string">&quot;Text&quot;</span>].<span class="built_in">toString</span>();</span><br></pre></td></tr></table></figure><p>读取Array键的值，将其转换成QJsonArray类型并赋值给array对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QJsonArray array = document.<span class="built_in">object</span>()[<span class="string">&quot;Array&quot;</span>].<span class="built_in">toArray</span>();</span><br></pre></td></tr></table></figure><p>使用for基于范围遍历array中的值，并输出item的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : array) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;ObjectName&quot;</span>].<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;Widget&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;High&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; item.<span class="built_in">toObject</span>()[<span class="string">&quot;Hide&quot;</span>].<span class="built_in">toBool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这便是一个简单的使用Qt框架中的Json模块反序列化的示例</p><h3 id="序列化示例"><a href="#序列化示例" class="headerlink" title="序列化示例"></a>序列化示例</h3><p>这段代码生成了一段Json文本并写入了test.json文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonArray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonDocument&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QJsonValue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/QCoreApplication&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">  QJsonDocument document;</span><br><span class="line">  QJsonObject jsonObject;</span><br><span class="line">  QJsonArray array;</span><br><span class="line">  file.<span class="built_in">open</span>(QIODeviceBase::WriteOnly);</span><br><span class="line">  <span class="function">QJsonValue <span class="title">value1</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line">  jsonObject.<span class="built_in">insert</span>(<span class="string">&quot;WelcomeText&quot;</span>, value1);</span><br><span class="line">  array.<span class="built_in">append</span>(<span class="built_in">QJsonValue</span>(<span class="string">&quot;ObjectName = Name&quot;</span>));</span><br><span class="line">  array.<span class="built_in">append</span>(<span class="built_in">QJsonValue</span>(<span class="string">&quot;Hei!&quot;</span>));</span><br><span class="line">  jsonObject.<span class="built_in">insert</span>(<span class="string">&quot;Array&quot;</span>, array);</span><br><span class="line">  document.<span class="built_in">setObject</span>(jsonObject);</span><br><span class="line">  file.<span class="built_in">write</span>(document.<span class="built_in">toJson</span>(QJsonDocument::Indented));</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line">  <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化需要的变量，设置file的文件名为test.json</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;test.json&quot;</span>)</span></span>;</span><br><span class="line">QJsonDocument document;</span><br><span class="line">QJsonObject jsonObject;</span><br></pre></td></tr></table></figure><p>使用只写模式打开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(QIODeviceBase::WriteOnly);</span><br></pre></td></tr></table></figure><p>构造一个QJsonValue并将其插入jsonObject中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QJsonValue <span class="title">value1</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line">jsonObject.<span class="built_in">insert</span>(<span class="string">&quot;WelcomeText&quot;</span>, value1);</span><br></pre></td></tr></table></figure><p>向array的尾部追加两个QJsonValue并插入到jsonObject中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="built_in">append</span>(<span class="built_in">QJsonValue</span>(<span class="string">&quot;ObjectName = Name&quot;</span>));</span><br><span class="line">array.<span class="built_in">append</span>(<span class="built_in">QJsonValue</span>(<span class="string">&quot;Hei!&quot;</span>));</span><br><span class="line">jsonObject.<span class="built_in">insert</span>(<span class="string">&quot;Array&quot;</span>, array);</span><br></pre></td></tr></table></figure><p>将jsonObject设置为document的主对象</p><p>将toJson使用Indented风格序列化出来的Json文本写入test.json文件中</p><p>并关闭test.json文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.<span class="built_in">setObject</span>(jsonObject);</span><br><span class="line">file.<span class="built_in">write</span>(document.<span class="built_in">toJson</span>(QJsonDocument::Indented));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>这段代码运行后会生成一个test.json文件，文件中内容为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Array&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;ObjectName = Name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Hei!&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;WelcomeText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后来首音乐放松一下吧</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=494858498&amp;auto=0&amp;height=66" style="transition-property: color, background, box-shadow, border-color; transition-delay: 0s, 0s, 0s, 0s; transition-duration: 0.2s, 0.2s, 0.2s, 0.2s; transition-timing-function: ease, ease, ease, ease; color: rgb(190, 190, 198); font-family: 霞鹜新晰黑, 霞鹜新晰黑, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 450; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(32, 33, 36); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇博客主要介绍Qt框架下的Json模块的使用&lt;/p&gt;
&lt;p&gt;注：Json模块已经嵌入到QCore中，无需引入其他模块&lt;/p&gt;
&lt;h2 id=&quot;需要使用的对象&quot;&gt;&lt;a href=&quot;#需要使用的对象&quot; class=&quot;headerlink&quot; title=&quot;需要使用的对象&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Qt" scheme="http://zjhzzy.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Linux下epoll的简单解释</title>
    <link href="http://zjhzzy.github.io/2023/08/11/Understanding-a-Simple-Example-of-epoll-Usage-in-Linux/"/>
    <id>http://zjhzzy.github.io/2023/08/11/Understanding-a-Simple-Example-of-epoll-Usage-in-Linux/</id>
    <published>2023-08-11T00:31:35.000Z</published>
    <updated>2023-09-30T12:02:48.706Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客是简单解释linux下的epoll</p><p>epoll是linux提供的一种I&#x2F;O事件通知机制，能够高效的处理文件描述符[1]的I&#x2F;O事件，其基于事件驱动</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> events;</span><br><span class="line">  <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">  <span class="type">void</span> *ptr;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">uint32_t</span> u32;</span><br><span class="line">  <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>events：事件</p><p>data：事件携带的数据，是一个联合体</p><p>ptr：一个C风格的any</p><p>fd：文件描述符</p><p>u32：一个无符号32位整型</p><p>u64：一个无符号64位整型</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p>epoll_create函数用来创建epoll的，需要传入一个int类型的变量用来指定最多监听几个描述符，如果没有出现错误便会返回一个文件描述符也就是int，如果出现错误会返回一个-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span></span><br></pre></td></tr></table></figure><p>epoll_ctl函数可以用来操作epoll文件描述符</p><p>epfd：epoll的文件描述符</p><p>op：对epoll文件描述符进行操作</p><p>fd：需要监听的文件描述符</p><p>event：要监听fd的哪些事件</p><p>op的有效值有 EPOLL_CTL_ADD EPOLL_CTL_MOD EPOLL_CTL_DEL 分别代表添加、修改、删除</p><blockquote><p>EPOLL_CTL_ADD：注册新的fd到epfd中；</p><p>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</p><p>EPOLL_CTL_DEL：从epfd中删除一个fd；</p></blockquote><p>event是一个集合，值可以为</p><blockquote><p>EPOLLIN：对应的文件描述符可以进行读取操作时获得通知</p><p>EPOLLOUT：对应的文件描述符可以进行写入操作时获得通知</p><p>EPOLLRDHUP：进行通信时对端关闭了连接或者写的操作时获得通知</p><p>EPOLLPRI：对应文件描述符有紧急数据可以进行读取时获得通知，一般是带外数据（Out-of-Band data)</p><p>EPOLLERR：对应文件描述符发生错误时获得通知</p><p>EPOLLHUP：发生挂起事件时，通常是对端关闭连接时获得通知</p><p>EPOLLET：会开启边缘触发模式，在文件描述符状态变化时获得通知</p><p>EPOLLONESHOT：表示启用一次事件通知，文件描述符会被设置成一次性模式，需要重新注册才会重新获取到通知</p><p>EPOLLEXCLUSIVE：表示该文件描述符为独占，不与1其他的文件描述符共享通知</p></blockquote><p>如果函数发生错误将返回-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure><p>epoll_wait执行后会阻塞线程，等待事件</p><p>epfd：epoll的文件描述符</p><p>events：用来存放被触发事件的数组</p><p>maxevents：数组的长度或最大接受事件的数量</p><p>timeout：超时时长，以毫秒为单位，超过该时间如果没有事件也会结束阻塞，如果为-1即代表阻塞到有事件被触发</p><p>返回值为int类型，表示的是触发了几个事件，如果出现错误便返回-1</p><h2 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h2><p>接下来会给出一个基于epoll的socket编程示例，并逐步解释来让你知道epoll该如何使用（会过关于套接字的部分），因为只是示例就不添加错误检查了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span><span class="comment">// 想使用epoll必须加上这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">  epoll_event epoll_events[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">  sockaddr_in addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = <span class="built_in">htons</span>(<span class="number">9888</span>);</span><br><span class="line">  <span class="built_in">bind</span>(sockfd, (sockaddr *) &amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line"></span><br><span class="line">  epoll_event event;</span><br><span class="line">  event.data.fd = sockfd;</span><br><span class="line">  event.events = (EPOLLIN);</span><br><span class="line">  <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, sockfd, &amp;event);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> event_nums = <span class="built_in">epoll_wait</span>(epollfd, epoll_events, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_nums; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (epoll_events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        sockaddr_in sock = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        std::string *buffer = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="number">1024</span>, <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        <span class="type">socklen_t</span> socklen = <span class="keyword">sizeof</span> sock;</span><br><span class="line">        <span class="built_in">recvfrom</span>(sockfd, buffer-&gt;<span class="built_in">data</span>(), buffer-&gt;<span class="built_in">length</span>(), <span class="number">0</span>, (sockaddr *) &amp;sock, &amp;socklen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s发送数据:%s&quot;</span>, std::<span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(sock.sin_addr)).<span class="built_in">c_str</span>(), buffer-&gt;<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">delete</span> buffer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先声明所有需要的变量</p><p>epollfd：epoll的文件描述符，使用epoll_create创建</p><p>epoll_events：前文提到过epoll是基于事件驱动的，所以这里面存放的是事件，初始化为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">epoll_event epoll_events[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>设置需要监听哪些事件，这里因为示例只监听了可读事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">epoll_event event;</span><br><span class="line">event.data.fd = fockfd;</span><br><span class="line">event.events = (EPOLLIN);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, sockfd, &amp;event);</span><br></pre></td></tr></table></figure><p>开始循环，等待事件，用event_nums来接收有多少个事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> event_nums = <span class="built_in">epoll_wait</span>(epollfd, epoll_events, <span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>遍历数组中的事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; event_nums; i++)</span><br></pre></td></tr></table></figure><p>判断其是否为写入事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (epoll_events[i].events &amp; EPOLLIN) </span><br></pre></td></tr></table></figure><p>对数据进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in sock = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::string *buffer = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="number">1024</span>, <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"><span class="type">socklen_t</span> socklen = <span class="keyword">sizeof</span> sock;</span><br><span class="line"><span class="built_in">recvfrom</span>(sockfd, buffer-&gt;<span class="built_in">data</span>(), buffer-&gt;<span class="built_in">length</span>(), <span class="number">0</span>, (sockaddr *) &amp;sock, &amp;socklen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s发送数据:%s&quot;</span>, std::<span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(sock.sin_addr)).<span class="built_in">c_str</span>(), buffer-&gt;<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">delete</span> buffer;</span><br></pre></td></tr></table></figure><p>这样便实现了一个简单的Udp服务器，当然epoll的用法不只是网络编程，还有更多的用法等待着你去探索，讲解就到这里了，如果有不清楚的可以在下面提问，我会尽力解答的</p><p>[1] 文件描述符：linux下一切皆是文件，文件描述符就是内核为了高效管理这些已经被打开的文件所创建的索引，想了解的可以看一下这篇<a href="https://zhuanlan.zhihu.com/p/512491366">文章 </a></p><p><strong>提示：epoll实例不需要显式关闭，但是要及时关闭其他不需要的文件描述符</strong> </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=472045266&amp;auto=0&amp;height=66" style="transition-property: color, background, box-shadow, border-color; transition-delay: 0s, 0s, 0s, 0s; transition-duration: 0.2s, 0.2s, 0.2s, 0.2s; transition-timing-function: ease, ease, ease, ease; color: rgb(190, 190, 198); font-family: 霞鹜新晰黑, 霞鹜新晰黑, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 450; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(32, 33, 36); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇博客是简单解释linux下的epoll&lt;/p&gt;
&lt;p&gt;epoll是linux提供的一种I&amp;#x2F;O事件通知机制，能够高效的处理文件描述符[1]的I&amp;#x2F;O事件，其基于事件驱动&lt;/p&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://zjhzzy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于C++中的条件变量的简单解释</title>
    <link href="http://zjhzzy.github.io/2023/08/10/About-Cpp-Condition-variables/"/>
    <id>http://zjhzzy.github.io/2023/08/10/About-Cpp-Condition-variables/</id>
    <published>2023-08-10T01:41:31.000Z</published>
    <updated>2023-10-02T13:16:33.043Z</updated>
    
    <content type="html"><![CDATA[<p>条件变量（condition variable）这是C++11加入的一个类 用于线程之间的通信</p><span id="more"></span><p>condition variable 类是同步原语[1] 能同时阻塞多个线程 直到共享变量被修改并通知 condition variable 时经过判断解除阻塞</p><p>下面演示条件变量的简单用法并且解释作用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mutex;</span><br><span class="line"><span class="type">bool</span> variable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> variable; &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">Thread</span><span class="params">(Print)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    variable = <span class="literal">true</span>;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    Thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明所需变量</p><p>cv：条件变量 上文解释过</p><p>mutex：互斥锁 对临界区[2]上锁避免竞态条件</p><p>variable：布尔 在 Print 函数中用来判断是否解除阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mutex;</span><br><span class="line"><span class="type">bool</span> variable = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>使用 mutex 初始化 unique_lock[3]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>阻塞线程</p><p>wait 需要传入两个参数</p><p>一个是unique_lock用于获取互斥锁（mutex）</p><p>一个是返回布尔（bool）的函数，在被唤醒后，如果返回值为真（true）就解除阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> variable; &#125;);</span><br></pre></td></tr></table></figure><p>输出 Hello World 代表函数执行完毕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>创建线程执行 Print 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">Thread</span><span class="params">(Print)</span></span>;</span><br></pre></td></tr></table></figure><p>将主线程暂停5秒</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>修改共享变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>解锁并通知条件变量 Print 中的 wait 判断后解除阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line">cv.<span class="built_in">notify_one</span>();</span><br></pre></td></tr></table></figure><p>等待线程执行完毕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p> <strong>提示：即使共享变量是原子的，也必须在互斥下修改它，以正确地发布修改到等待的线程</strong></p><p>[1] 同步原语：如互斥锁，对临界区上锁以避免竞态条件保证线程安全性</p><p>[2] 临界区：指的是一个访问共享资源的代码块</p><p>[3] unique_lock：是一种通用互斥包装器，提供了更灵活的加锁和解锁操作</p><p>最后来听首歌放松一下吧</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=521935820&amp;auto=0&amp;height=66" style="transition-property: color, background, box-shadow, border-color; transition-delay: 0s, 0s, 0s, 0s; transition-duration: 0.2s, 0.2s, 0.2s, 0.2s; transition-timing-function: ease, ease, ease, ease; color: rgb(190, 190, 198); font-family: 霞鹜新晰黑, 霞鹜新晰黑, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 450; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(32, 33, 36); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;条件变量（condition variable）这是C++11加入的一个类 用于线程之间的通信&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="多线程" scheme="http://zjhzzy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数传值、引用还是指针？</title>
    <link href="http://zjhzzy.github.io/2023/08/08/Should-I-pass-by-value-pass-by-pointer-or-pass-by-reference/"/>
    <id>http://zjhzzy.github.io/2023/08/08/Should-I-pass-by-value-pass-by-pointer-or-pass-by-reference/</id>
    <published>2023-08-08T02:44:37.000Z</published>
    <updated>2023-09-30T11:56:52.466Z</updated>
    
    <content type="html"><![CDATA[<p>在学习C++的过程中有些新手可能听说了C++传引用减少拷贝次数增快程序速度，然后就会去一股脑全部使用引用</p><p>这篇博客就是来简单说明一下让新手有些了解</p><p>本文仅作本人经验所记，并不是很全面</p><h1 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h1><p>这是一般学习C++时接触的第一种传参方式比如这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传值会有一定的损耗 因为需要将传入的参数复制一遍再传入函数中</p><p>参数的值只能传入 不能传出</p><p>这个一般适用于 可以轻松复制的类型并且足够的小 比如 int、float、double 之类的</p><h1 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h1><p>在需要操作修改外部的值的时候就需要传引用来解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b,<span class="type">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">    c = a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就减少了复制的操作</p><p>但是这样并不是适合于所有的 最好不要传原始数据类型 这样可能会阻止编译器优化</p><p>适用于那些 自定义的类</p><h1 id="传const引用"><a href="#传const引用" class="headerlink" title="传const引用"></a>传const引用</h1><p>这个适用于不修改传入参数的值，保证其不被改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a,<span class="type">const</span> <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传指针"><a href="#传指针" class="headerlink" title="传指针"></a>传指针</h1><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b,<span class="type">int</span>* c)</span></span>&#123;</span><br><span class="line">    *c = *a+*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提示：编译器并不总是遵循你指定的参数传递约定</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习C++的过程中有些新手可能听说了C++传引用减少拷贝次数增快程序速度，然后就会去一股脑全部使用引用&lt;/p&gt;
&lt;p&gt;这篇博客就是来简单说明一下让新手有些了解&lt;/p&gt;
&lt;p&gt;本文仅作本人经验所记，并不是很全面&lt;/p&gt;
&lt;h1 id=&quot;传值&quot;&gt;&lt;a href=&quot;#传值&quot; c</summary>
      
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Qt 中的重载 paintEvent 方法：示例和解析</title>
    <link href="http://zjhzzy.github.io/2023/07/14/QtPaintEventFunOverride/"/>
    <id>http://zjhzzy.github.io/2023/07/14/QtPaintEventFunOverride/</id>
    <published>2023-07-14T10:58:29.000Z</published>
    <updated>2023-10-01T00:21:45.160Z</updated>
    
    <content type="html"><![CDATA[<p>学了qss之后会了一些美化，但是发现还有很多qss没法实现，那么这个文章就适合你了</p><span id="more"></span><p>当然不喜欢使用qss的比如我，也可以通过该文章快速学习通过重载paintEvent来绘制你想要的控件</p><p>paintEvent是一个虚函数，需要子类进行重载才能实现自定义绘制</p><p>paintEvent是一个绘制函数，会在调用后绘制图形</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>这里先给出一个示例，然后来逐步解析这个示例让你理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtWidget::paintEvent</span><span class="params">(QPaintEvent* Event)</span> </span>&#123;</span><br><span class="line">  QWidget::<span class="built_in">paintEvent</span>(Event);</span><br><span class="line">  <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="function">QPen <span class="title">pen</span><span class="params">(QColor(<span class="string">&quot;#b883a0&quot;</span>))</span></span>;</span><br><span class="line">  <span class="function">QBrush <span class="title">brush</span><span class="params">(QColor(<span class="string">&quot;#b883a0&quot;</span>))</span></span>;</span><br><span class="line">  painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">  painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">  painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span>(), <span class="built_in">height</span>()));</span><br><span class="line">  painter.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一段简单的代码你就得到了一个圆</p><p>接下来逐步解析这段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QWidget::<span class="built_in">paintEvent</span>(Event);</span><br></pre></td></tr></table></figure><p>这段代码，是调用父类的绘制函数，来绘制一些默认和设置过后的图形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>声明了一个QPainter对象，它是一个画笔，可以用来绘制你想在控件上绘制的图形</p><p>QPainter的构造函数需要传入QPainterDevice，你不知道这是啥，没关系，你只要知道Qt中所有的控件都是它的子类就行了</p><p>这里我们传入了当前对象的指针，作为这个QPainter的绘图设备</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPen <span class="title">pen</span><span class="params">(QColor(<span class="string">&quot;#b883a0&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>这里传入了一个QColor也就是颜色去构造pen，QPen是一个画笔，当然它和前面的QPainter不一样，它储存着画笔的信息，是用来画图形的边框的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QBrush <span class="title">brush</span><span class="params">(QColor(<span class="string">&quot;#b883a0&quot;</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>QBrush是一个画刷，它储存的是填充封闭图形的画刷的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">painter.<span class="built_in">setBrush</span>(brush);</span><br></pre></td></tr></table></figure><p>这里应该不用过多解释了，将pen和brush分别传入painter中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">width</span>(), <span class="built_in">height</span>()));</span><br></pre></td></tr></table></figure><p>painter对象调用了drawEllipse函数绘制了一个圆，传入了一个QRect，QRect构造函数中的参数分别是（x轴坐标，y轴坐标，控件的宽，控件的高）</p><p>更多的绘制函数，可以参阅<a href="https://doc.qt.io/qt-6/qpainter.html">Qt文档 </a>里面有解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">painter.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure><p>最后调用end函数，结束绘画，当然不止end函数能结束绘制，销毁painter也是会结束绘制的</p><p>实现了这么个窗口</p><p><img src="https://zjhzzy.github.io/image/QtPaintEventOverride.png" alt="ProgramWindow"></p><p>相信到这里已经明白paintEvent函数后需要干什么和怎样绘制自己想要的控件了</p><hr><h1 id="解释部分"><a href="#解释部分" class="headerlink" title="解释部分"></a>解释部分</h1><h2 id="上文没有讲到的类"><a href="#上文没有讲到的类" class="headerlink" title="上文没有讲到的类"></a>上文没有讲到的类</h2><h3 id="QFont"><a href="#QFont" class="headerlink" title="QFont"></a>QFont</h3><p>这是一个字体类，里面储存了字体的信息，传入QPainter对象后，会在调用drawText时被读取</p><h2 id="paintEvent的触发时机和方式"><a href="#paintEvent的触发时机和方式" class="headerlink" title="paintEvent的触发时机和方式"></a>paintEvent的触发时机和方式</h2><p>接下来说paintEvent会在什么时候被调用</p><ol><li>show()<br>这是一个显示函数，它会调用paintEvent来绘制图形，注意，只有在被隐藏之后调用show()才会调用paintEvent来绘制，已经调用一次show()且没有调用hide()隐藏是不会调用paintEvent来重绘的，如果状态改变了需要重绘可以看下文的两个函数</li><li>updata()<br>这是一个重绘函数，它不会立即调用paintEvent来重绘图形，它会返回主事件循环时安排一个绘制事件进行处理，Qt会对其优化速度和减少闪烁，updata()在调用之后通常只会调用一次paintEvent，当然也会有例外，见下文给出的文章</li><li>repaint()<br>这是一个重绘函数，它会直接调用paintEvent来重绘图形<br>这个函数有风险，可能会一直递归循环调用父类的paintEvent，最好是在需要快速重绘的时候，比如动画等等，再去调用</li><li>窗口大小修改后<br>比如拉动窗口边缘去改变窗口大小的时候就会直接调用paintEvent函数去重绘图形</li></ol><p>Qt的文档给出了说明：</p><p>Warning: If you call repaint() in a function which may itself be called from paintEvent(), you may get infinite recursion. The update() function never causes recursion.</p><p><a href="https://blog.csdn.net/holidayi/article/details/108330072">自定义绘制paintEvent方法导致的递归循环</a> 文章有解释，可以去看看</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点当然是自定义程度高，可以绘制一切你想绘制的图形</p><p>缺点对于小白来说，复用性不高，可能这个类到另外一个场景就要再写一个，当然使用一些时间后就会知道如何增加复用性</p><p>去增加几个成员变量，在使用paintEvent去绘制时根据你的成员变量去绘制也能提高复用性</p><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QtWidget.h</span></span><br><span class="line">QString TextColor;</span><br><span class="line">QString Text;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(QString color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(QString text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* Event)</span></span>;</span><br><span class="line"><span class="comment">//QtWidget.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtWidget::paintEvent</span><span class="params">(QPaintEvent* Event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setFont</span>(<span class="built_in">QFont</span>(<span class="string">&quot;宋体&quot;</span>,<span class="number">15</span>));</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="string">&quot;#f6cf9b&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="string">&quot;#f6cf9b&quot;</span>));</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">0</span>,<span class="number">0</span>,Text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面就定义了两个成员变量，在paintEvent中绘制，增加了复用性</p><p>本文就到这里了，如果有什么地方写错了，可以在下面提出来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了qss之后会了一些美化，但是发现还有很多qss没法实现，那么这个文章就适合你了&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zjhzzy.github.io/tags/C/"/>
    
    <category term="Qt" scheme="http://zjhzzy.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt 在线下载速度慢的解决方法</title>
    <link href="http://zjhzzy.github.io/2023/07/14/QtOnlineDownload/"/>
    <id>http://zjhzzy.github.io/2023/07/14/QtOnlineDownload/</id>
    <published>2023-07-14T03:54:32.000Z</published>
    <updated>2023-10-01T00:21:37.762Z</updated>
    
    <content type="html"><![CDATA[<p>Qt 在线下载速度慢的解决方法</p><span id="more"></span><p>下载地址</p><p><a href="https://download.qt.io/archive/online_installers/">Qt 官网（较慢） </a></p><p><a href="http://mirrors.ustc.edu.cn/qtproject/archive/online_installers/">中国科学技术大学 </a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/online_installers/">清华大学 </a></p><p><a href="https://mirrors.bit.edu.cn/qtproject/archive/online_installers/">北京理工大学 </a></p><p><a href="https://mirrors.aliyun.com/qt/archive/online_installers/">阿里云开源镜像站 </a></p><p>下载好后在对应目录下打开管理员终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应安装包名 --mirror https://mirrors.sjtug.sjtu.edu.cn/qt</span><br></pre></td></tr></table></figure><p>这个是清华源不限速，也可以使用其他的镜像源</p><p>这样的下载速度就可以加快了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Qt 在线下载速度慢的解决方法&lt;/p&gt;</summary>
    
    
    
    
    <category term="Qt" scheme="http://zjhzzy.github.io/tags/Qt/"/>
    
  </entry>
  
</feed>
